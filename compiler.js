/**
 * TTTTTTTTTTTTTTTTTTTTTTTHHHHHHHHH     HHHHHHHHHEEEEEEEEEEEEEEEEEEEEEE
 * T:::::::::::::::::::::TH:::::::H     H:::::::HE::::::::::::::::::::E
 * T:::::::::::::::::::::TH:::::::H     H:::::::HE::::::::::::::::::::E
 * T:::::TT:::::::TT:::::THH::::::H     H::::::HHEE::::::EEEEEEEEE::::E
 * TTTTTT  T:::::T  TTTTTT  H:::::H     H:::::H    E:::::E       EEEEEE
 *         T:::::T          H:::::H     H:::::H    E:::::E
 *         T:::::T          H::::::HHHHH::::::H    E::::::EEEEEEEEEE
 *         T:::::T          H:::::::::::::::::H    E:::::::::::::::E
 *         T:::::T          H:::::::::::::::::H    E:::::::::::::::E
 *         T:::::T          H::::::HHHHH::::::H    E::::::EEEEEEEEEE
 *         T:::::T          H:::::H     H:::::H    E:::::E
 *         T:::::T          H:::::H     H:::::H    E:::::E       EEEEEE
 *       TT:::::::TT      HH::::::H     H::::::HHEE::::::EEEEEEEE:::::E
 *       T:::::::::T      H:::::::H     H:::::::HE::::::::::::::::::::E
 *       T:::::::::T      H:::::::H     H:::::::HE::::::::::::::::::::E
 *       TTTTTTTTTTT      HHHHHHHHH     HHHHHHHHHEEEEEEEEEEEEEEEEEEEEEE
 *
 *    SSSSSSSSSSSSSSS UUUUUUUU     UUUUUUUUPPPPPPPPPPPPPPPPP   EEEEEEEEEEEEEEEEEEEEEERRRRRRRRRRRRRRRRR
 *  SS:::::::::::::::SU::::::U     U::::::UP::::::::::::::::P  E::::::::::::::::::::ER::::::::::::::::R
 * S:::::SSSSSS::::::SU::::::U     U::::::UP::::::PPPPPP:::::P E::::::::::::::::::::ER::::::RRRRRR:::::R
 * S:::::S     SSSSSSSUU:::::U     U:::::UUPP:::::P     P:::::PEE::::::EEEEEEEEE::::ERR:::::R     R:::::R
 * S:::::S             U:::::U     U:::::U   P::::P     P:::::P  E:::::E       EEEEEE  R::::R     R:::::R
 * S:::::S             U:::::U     U:::::U   P::::P     P:::::P  E:::::E               R::::R     R:::::R
 *  S::::SSSS          U:::::U     U:::::U   P::::PPPPPP:::::P   E::::::EEEEEEEEEE     R::::RRRRRR:::::R
 *   SS::::::SSSSS     U:::::U     U:::::U   P:::::::::::::PP    E:::::::::::::::E     R:::::::::::::RR
 *     SSS::::::::SS   U:::::U     U:::::U   P::::PPPPPPPPP      E:::::::::::::::E     R::::RRRRRR:::::R
 *        SSSSSS::::S  U:::::U     U:::::U   P::::P              E::::::EEEEEEEEEE     R::::R     R:::::R
 *             S:::::S U:::::U     U:::::U   P::::P              E:::::E               R::::R     R:::::R
 *             S:::::S U::::::U   U::::::U   P::::P              E:::::E       EEEEEE  R::::R     R:::::R
 * SSSSSSS     S:::::S U:::::::UUU:::::::U PP::::::PP          EE::::::EEEEEEEE:::::ERR:::::R     R:::::R
 * S::::::SSSSSS:::::S  UU:::::::::::::UU  P::::::::P          E::::::::::::::::::::ER::::::R     R:::::R
 * S:::::::::::::::SS     UU:::::::::UU    P::::::::P          E::::::::::::::::::::ER::::::R     R:::::R
 *  SSSSSSSSSSSSSSS         UUUUUUUUU      PPPPPPPPPP          EEEEEEEEEEEEEEEEEEEEEERRRRRRRR     RRRRRRR
 *
 * TTTTTTTTTTTTTTTTTTTTTTTIIIIIIIIIINNNNNNNN        NNNNNNNNYYYYYYY       YYYYYYY
 * T:::::::::::::::::::::TI::::::::IN:::::::N       N::::::NY:::::Y       Y:::::Y
 * T:::::::::::::::::::::TI::::::::IN::::::::N      N::::::NY:::::Y       Y:::::Y
 * T:::::TT:::::::TT:::::TII::::::IIN:::::::::N     N::::::NY::::::Y     Y::::::Y
 * TTTTTT  T:::::T  TTTTTT  I::::I  N::::::::::N    N::::::NYYY:::::Y   Y:::::YYY
 *         T:::::T          I::::I  N:::::::::::N   N::::::N   Y:::::Y Y:::::Y
 *         T:::::T          I::::I  N:::::::N::::N  N::::::N    Y:::::Y:::::Y
 *         T:::::T          I::::I  N::::::N N::::N N::::::N     Y:::::::::Y
 *         T:::::T          I::::I  N::::::N  N::::N:::::::N      Y:::::::Y
 *         T:::::T          I::::I  N::::::N   N:::::::::::N       Y:::::Y
 *         T:::::T          I::::I  N::::::N    N::::::::::N       Y:::::Y
 *         T:::::T          I::::I  N::::::N     N:::::::::N       Y:::::Y
 *       TT:::::::TT      II::::::IIN::::::N      N::::::::N       Y:::::Y
 *       T:::::::::T      I::::::::IN::::::N       N:::::::N    YYYY:::::YYYY
 *       T:::::::::T      I::::::::IN::::::N        N::::::N    Y:::::::::::Y
 *       TTTTTTTTTTT      IIIIIIIIIINNNNNNNN         NNNNNNN    YYYYYYYYYYYYY
 *
 *         CCCCCCCCCCCCC     OOOOOOOOO     MMMMMMMM               MMMMMMMMPPPPPPPPPPPPPPPPP   IIIIIIIIIILLLLLLLLLLL             EEEEEEEEEEEEEEEEEEEEEERRRRRRRRRRRRRRRRR
 *      CCC::::::::::::C   OO:::::::::OO   M:::::::M             M:::::::MP::::::::::::::::P  I::::::::IL:::::::::L             E::::::::::::::::::::ER::::::::::::::::R
 *    CC:::::::::::::::C OO:::::::::::::OO M::::::::M           M::::::::MP::::::PPPPPP:::::P I::::::::IL:::::::::L             E::::::::::::::::::::ER::::::RRRRRR:::::R
 *   C:::::CCCCCCCC::::CO:::::::OOO:::::::OM:::::::::M         M:::::::::MPP:::::P     P:::::PII::::::IILL:::::::LL             EE::::::EEEEEEEEE::::ERR:::::R     R:::::R
 *  C:::::C       CCCCCCO::::::O   O::::::OM::::::::::M       M::::::::::M  P::::P     P:::::P  I::::I    L:::::L                 E:::::E       EEEEEE  R::::R     R:::::R
 * C:::::C              O:::::O     O:::::OM:::::::::::M     M:::::::::::M  P::::P     P:::::P  I::::I    L:::::L                 E:::::E               R::::R     R:::::R
 * C:::::C              O:::::O     O:::::OM:::::::M::::M   M::::M:::::::M  P::::PPPPPP:::::P   I::::I    L:::::L                 E::::::EEEEEEEEEE     R::::RRRRRR:::::R
 * C:::::C              O:::::O     O:::::OM::::::M M::::M M::::M M::::::M  P:::::::::::::PP    I::::I    L:::::L                 E:::::::::::::::E     R:::::::::::::RR
 * C:::::C              O:::::O     O:::::OM::::::M  M::::M::::M  M::::::M  P::::PPPPPPPPP      I::::I    L:::::L                 E:::::::::::::::E     R::::RRRRRR:::::R
 * C:::::C              O:::::O     O:::::OM::::::M   M:::::::M   M::::::M  P::::P              I::::I    L:::::L                 E::::::EEEEEEEEEE     R::::R     R:::::R
 * C:::::C              O:::::O     O:::::OM::::::M    M:::::M    M::::::M  P::::P              I::::I    L:::::L                 E:::::E               R::::R     R:::::R
 *  C:::::C       CCCCCCO::::::O   O::::::OM::::::M     MMMMM     M::::::M  P::::P              I::::I    L:::::L         LLLLLL  E:::::E       EEEEEE  R::::R     R:::::R
 *   C:::::CCCCCCCC::::CO:::::::OOO:::::::OM::::::M               M::::::MPP::::::PP          II::::::IILL:::::::LLLLLLLLL:::::LEE::::::EEEEEEEE:::::ERR:::::R     R:::::R
 *    CC:::::::::::::::C OO:::::::::::::OO M::::::M               M::::::MP::::::::P          I::::::::IL::::::::::::::::::::::LE::::::::::::::::::::ER::::::R     R:::::R
 *      CCC::::::::::::C   OO:::::::::OO   M::::::M               M::::::MP::::::::P          I::::::::IL::::::::::::::::::::::LE::::::::::::::::::::ER::::::R     R:::::R
 *         CCCCCCCCCCCCC     OOOOOOOOO     MMMMMMMM               MMMMMMMMPPPPPPPPPP          IIIIIIIIIILLLLLLLLLLLLLLLLLLLLLLLLEEEEEEEEEEEEEEEEEEEEEERRRRRRRR     RRRRRRR
 *
 * =======================================================================================================================================================================
 * =======================================================================================================================================================================
 * =======================================================================================================================================================================
 * =======================================================================================================================================================================
 */


/**
 * 今天我们将一起编写一个编译器。但这不是一个普通的编译器...这是一个超级小巧的编译器！
 * 一个如此小的编译器，以至于如果你删除所有注释，这个文件只有大约200行实际代码。
 *
 * 我们将把一些类似Lisp的函数调用编译成类似C的函数调用。
 *
 * 如果你对其中一种或两种都不熟悉，我会给你一个简单的介绍。
 *
 * 如果我们有两个函数 `add` 和 `subtract`，它们将这样写:
 *
 *                  LISP                      C
 *
 *   2 + 2          (add 2 2)                 add(2, 2)
 *   4 - 2          (subtract 4 2)            subtract(4, 2)
 *   2 + (4 - 2)    (add 2 (subtract 4 2))    add(2, subtract(4, 2))
 *
 * 很简单对吧？
 *
 * 很好，因为这正是我们要编译的内容。虽然这既不是完整的LISP语法也不是完整的C语法，
 * 但它将包含足够的语法来展示现代编译器的许多主要部分。
 */


/**
 * 大多数编译器分为三个主要阶段：解析、转换和代码生成
 *
 * 1. *解析*是将原始代码转换为更抽象的代码表示。
 *
 * 2. *转换*接受这个抽象表示并对其进行操作，以完成编译器想要做的任何事情。
 *
 * 3. *代码生成*将转换后的代码表示转换为新的代码。
 */

/**
 * 解析
 * ----
 *
 * 解析通常分为两个阶段：词法分析和语法分析。
 *
 * 1. *词法分析*接收原始代码，并通过一个称为分词器（或词法分析器）的工具将其分割成称为标记（token）的东西。
 *
 *    标记是一个由微小对象组成的数组，这些对象描述了语法的独立部分。它们可以是数字、标签、标点符号、运算符等。
 *
 * 2. *语法分析*接收这些标记，并将它们重新格式化为一种描述语法每个部分及其相互关系的表示。
 *    这被称为中间表示或抽象语法树。
 *
 *    抽象语法树（简称AST）是一个深度嵌套的对象，它以一种既易于使用又能告诉我们大量信息的方式表示代码。
 *
 * 对于以下语法：
 *
 *   (add 2 (subtract 4 2))
 *
 * 标记可能看起来像这样：
 *
 *   [
 *     { type: 'paren',  value: '('        },
 *     { type: 'name',   value: 'add'      },
 *     { type: 'number', value: '2'        },
 *     { type: 'paren',  value: '('        },
 *     { type: 'name',   value: 'subtract' },
 *     { type: 'number', value: '4'        },
 *     { type: 'number', value: '2'        },
 *     { type: 'paren',  value: ')'        },
 *     { type: 'paren',  value: ')'        },
 *   ]
 *
 * 而抽象语法树（AST）可能看起来像这样：
 *
 *   {
 *     type: 'Program',
 *     body: [{
 *       type: 'CallExpression',
 *       name: 'add',
 *       params: [{
 *         type: 'NumberLiteral',
 *         value: '2',
 *       }, {
 *         type: 'CallExpression',
 *         name: 'subtract',
 *         params: [{
 *           type: 'NumberLiteral',
 *           value: '4',
 *         }, {
 *           type: 'NumberLiteral',
 *           value: '2',
 *         }]
 *       }]
 *     }]
 *   }
 */

/**
 * 转换
 * ----
 *
 * 编译器的下一个阶段是转换。这个阶段接收上一步得到的AST并对其进行修改。它可以在同一种语言中操作AST，
 * 也可以将其翻译成一种全新的语言。
 *
 * 让我们看看如何转换AST。
 *
 * 你可能注意到我们的AST中有一些看起来非常相似的元素。这些是带有type属性的对象。每一个都被称为AST节点。
 * 这些节点有定义好的属性，用于描述树中的一个独立部分。
 *
 * 我们可以有一个表示"NumberLiteral"的节点：
 *
 *   {
 *     type: 'NumberLiteral',
 *     value: '2',
 *   }
 *
 * 或者一个表示"CallExpression"的节点：
 *
 *   {
 *     type: 'CallExpression',
 *     name: 'subtract',
 *     params: [...嵌套的节点放在这里...],
 *   }
 *
 * 在转换AST时，我们可以通过添加/删除/替换属性来操作节点，可以添加新节点，删除节点，
 * 或者我们可以保持现有的AST不变，并基于它创建一个全新的AST。
 *
 * 由于我们的目标是一种新的语言，我们将专注于创建一个全新的、特定于目标语言的AST。
 *
 * 遍历
 * ----
 *
 * 为了浏览所有这些节点，我们需要能够遍历它们。这个遍历过程会以深度优先的方式访问AST中的每个节点。
 *
 *   {
 *     type: 'Program',
 *     body: [{
 *       type: 'CallExpression',
 *       name: 'add',
 *       params: [{
 *         type: 'NumberLiteral',
 *         value: '2'
 *       }, {
 *         type: 'CallExpression',
 *         name: 'subtract',
 *         params: [{
 *           type: 'NumberLiteral',
 *           value: '4'
 *         }, {
 *           type: 'NumberLiteral',
 *           value: '2'
 *         }]
 *       }]
 *     }]
 *   }
 *
 * 对于上面的AST，我们会按以下顺序遍历：
 *
 *   1. Program - 从AST的顶层开始
 *   2. CallExpression (add) - 移动到Program的body的第一个元素
 *   3. NumberLiteral (2) - 移动到CallExpression的params的第一个元素
 *   4. CallExpression (subtract) - 移动到CallExpression的params的第二个元素
 *   5. NumberLiteral (4) - 移动到CallExpression的params的第一个元素
 *   6. NumberLiteral (2) - 移动到CallExpression的params的第二个元素
 *
 * 如果我们直接操作这个AST，而不是创建一个单独的AST，我们可能会在这里引入各种抽象。
 * 但是对于我们想要做的事情来说，仅仅访问树中的每个节点就足够了。
 *
 * 我之所以使用"访问"这个词，是因为有一种模式用于表示对对象结构元素的操作。
 *
 * 访问者
 * ------
 *
 * 这里的基本思想是，我们将创建一个"访问者"对象，该对象有接受不同节点类型的方法。
 *
 *   var visitor = {
 *     NumberLiteral() {},
 *     CallExpression() {},
 *   };
 *
 * 当我们遍历AST时，每当我们"进入"一个匹配类型的节点时，我们就会调用这个访问者上的方法。
 *
 * 为了使这个有用，我们还将传递节点和对父节点的引用。
 *
 *   var visitor = {
 *     NumberLiteral(node, parent) {},
 *     CallExpression(node, parent) {},
 *   };
 *
 * 然而，也存在在"退出"时调用东西的可能性。想象一下我们之前的树结构的列表形式：
 *
 *   - Program
 *     - CallExpression
 *       - NumberLiteral
 *       - CallExpression
 *         - NumberLiteral
 *         - NumberLiteral
 *
 * 当我们向下遍历时，我们会到达死胡同的分支。当我们完成树的每个分支时，我们就"退出"它。
 * 所以在下行树时我们"进入"每个节点，在上行时我们"退出"。
 *
 *   -> Program (enter)
 *     -> CallExpression (enter)
 *       -> Number Literal (enter)
 *       <- Number Literal (exit)
 *       -> Call Expression (enter)
 *          -> Number Literal (enter)
 *          <- Number Literal (exit)
 *          -> Number Literal (enter)
 *          <- Number Literal (exit)
 *       <- CallExpression (exit)
 *     <- CallExpression (exit)
 *   <- Program (exit)
 *
 * 为了支持这一点，我们的访问者的最终形式将如下所示：
 *
 *   var visitor = {
 *     NumberLiteral: {
 *       enter(node, parent) {},
 *       exit(node, parent) {},
 *     }
 *   };
 */


/**
 * 代码生成
 * --------
 *
 * 编译器的最后阶段是代码生成。有时编译器会做一些与转换重叠的事情，但大部分
 * 情况下，代码生成只是意味着取我们的AST并将代码重新字符串化输出。
 *
 * 代码生成器以几种不同的方式工作，一些编译器会重用之前的标记，其他的会创建
 * 代码的单独表示，以便他们可以线性地打印节点，但据我所知，大多数会使用我们
 * 刚刚创建的相同AST，这也是我们将要关注的。
 *
 * 实际上，我们的代码生成器将知道如何"打印"AST的所有不同节点类型，它会递归
 * 地调用自身来打印嵌套节点，直到所有内容都被打印成一个长字符串的代码。
 */


/**
 * 就是这样！这就是编译器的所有不同部分。
 *
 * 现在，这并不是说每个编译器都完全像我在这里描述的那样。编译器服务于许多
 * 不同的目的，它们可能需要比我详细描述的更多的步骤。
 *
 * 但现在你应该对大多数编译器的大体高级结构有了一个总体的了解。
 *
 * 现在我已经解释了所有这些，你们都准备好去编写自己的编译器了，对吧？
 *
 * 开玩笑的，这就是我在这里帮助你们的原因 :P
 *
 * 那么让我们开始吧...
 */

/**
 * 我们将从解析的第一个阶段开始,即词法分析,
 * 使用分词器。
 *
 * 我们只是将代码字符串分解成一个
 * 令牌数组。
 *
 *   (add 2 (subtract 4 2))   =>   [{ type: 'paren', value: '(' }, ...]
 */


/**
 * ============================================================================
 *                                   (/^▽^)/
 *                                THE TOKENIZER!
 * ============================================================================
 */


// 我们首先接受一个输入的代码字符串,然后我们将设置两个
// 东西...
function tokenizer(input) {

    // 一个 `current` 变量用于跟踪我们在代码中的位置,就像光标一样。
    let current = 0;

    // 还有一个 `tokens` 数组用于存放我们的令牌。
    let tokens = [];

    // 我们首先创建一个 `while` 循环,在这里我们设置我们的 `current`
    // 变量,使其可以在循环"内部"根据需要递增。
    //
    // 我们这样做是因为我们可能需要在单个循环中多次递增 `current`,
    // 因为我们的令牌可以是任意长度。
    while (current < input.length) {

        // 我们还要存储输入中的 `current` 字符。
        let char = input[current];

        // 我们要检查的第一件事是开括号。这将
        // 稍后用于 `CallExpression`,但现在我们只关心
        // 字符本身。
        //
        // 我们检查是否有一个开括号:
        if (char === '(') {

            // 如果有,我们推入一个新的令牌,类型为 `paren`,值
            // 设置为开括号。
            tokens.push({
                type: 'paren',
                value: '(',
            });

            // 然后我们递增 `current`
            current++;

            // 然后我们 `continue` 进入循环的下一个周期。
            continue;
        }

        // 接下来我们要检查闭括号。我们做完全相同的
        // 事情:检查闭括号,添加一个新令牌,
        // 递增 `current`,然后 `continue`。
        if (char === ')') {
            tokens.push({
                type: 'paren',
                value: ')',
            });
            current++;
            continue;
        }

        // 继续,我们现在要检查空白。这很有趣
        // 因为我们关心空白的存在是为了分隔字符,但它
        // 实际上对我们来说并不重要,不需要作为令牌存储。我们只会稍后
        // 将其丢弃。
        //
        // 所以在这里我们只是测试其存在,如果存在,我们
        // 就只是 `continue`。
        let WHITESPACE = /\s/;
        if (WHITESPACE.test(char)) {
            current++;
            continue;
        }

        // 下一种类型的令牌是数字。这与我们之前
        // 看到的不同,因为数字可以是任意数量的字符,我们
        // 想要将整个字符序列捕获为一个令牌。
        //
        //   (add 123 456)
        //        ^^^ ^^^
        //        只有两个单独的令牌
        //
        // 所以当我们遇到序列中的第一个数字时,我们就开始这个过程。
        let NUMBERS = /[0-9]/;
        if (NUMBERS.test(char)) {

            // 我们要创建一个 `value` 字符串,我们将向其
            // 推入字符。
            let value = '';

            // 然后我们要循环遍历序列中的每个字符,直到
            // 我们遇到一个不是数字的字符,将每个
            // 是数字的字符推入我们的 `value`,并在过程中递增 `current`。
            while (NUMBERS.test(char)) {
                value += char;
                char = input[++current];
            }

            // 之后我们将我们的 `number` 令牌推入 `tokens` 数组。
            tokens.push({ type: 'number', value });

            // 然后我们继续。
            continue;
        }

        // 我们还将在我们的语言中添加对字符串的支持,它将是任何
        // 被双引号(")包围的文本。
        //
        //   (concat "foo" "bar")
        //            ^^^   ^^^ 字符串令牌
        //
        // 我们将从检查开始引号开始:
        if (char === '"') {
            // 保留一个 `value` 变量用于构建我们的字符串令牌。
            let value = '';

            // 我们将跳过我们令牌中的开始双引号。
            char = input[++current];

            // 然后我们将遍历每个字符,直到我们到达另一个
            // 双引号。
            while (char !== '"') {
                value += char;
                char = input[++current];
            }

            // 跳过结束的双引号。
            char = input[++current];

            // 并将我们的 `string` 令牌添加到 `tokens` 数组中。
            tokens.push({ type: 'string', value });

            continue;
        }

        // 最后一种类型的令牌将是 `name` 令牌。这是一个
        // 字母序列而不是数字,它们是我们的 lisp
        // 语法中函数的名称。
        //
        //   (add 2 4)
        //    ^^^
        //    名称令牌
        //
        let LETTERS = /[a-z]/i;
        if (LETTERS.test(char)) {
            let value = '';

            // 再次,我们只是要循环遍历所有字母,将它们推入
            // 一个值中。
            while (LETTERS.test(char)) {
                value += char;
                char = input[++current];
            }

            // 并将该值作为类型为 `name` 的令牌推入并继续。
            tokens.push({ type: 'name', value });

            continue;
        }

        // 最后,如果到现在我们还没有匹配到一个字符,我们将
        // 抛出一个错误并完全退出。
        throw new TypeError('我不知道这个字符是什么: ' + char);
    }

    // 然后在我们的 `tokenizer` 的末尾,我们简单地返回 tokens 数组。
    return tokens;
}


/**
 * ============================================================================
 *                                 ヽ/❀o ل͜ o\ﾉ
 *                                THE PARSER!!!
 * ============================================================================
 */


/**
 * 我们的解析器将把 token 数组转换成 AST。
 *
 *   [{ type: 'paren', value: '(' }, ...]   =>   { type: 'Program', body: [...] }
 */

// 定义一个 `parser` 函数，接收 `tokens` 数组作为参数。
function parser(tokens) {

    // 我们再次使用一个 `current` 变量作为游标。
    let current = 0;

    // 但这次我们将使用递归而不是 `while` 循环。因此定义一个 `walk` 函数。
    function walk() {

        // 在 `walk` 函数内部，我们首先获取当前的 `token`。
        let token = tokens[current];

        // 我们将每种类型的 token 分成不同的代码路径，首先处理 `number` 类型的 token。
        //
        // 检查当前 token 是否为 `number` 类型。
        if (token.type === 'number') {

            // 如果是，我们将 `current` 递增。
            current++;

            // 然后返回一个新的 AST 节点，类型为 `NumberLiteral`，并将其值设置为 token 的值。
            return {
                type: 'NumberLiteral',
                value: token.value,
            };
        }

        // 如果是字符串类型，我们执行与数字类型类似的操作，创建一个 `StringLiteral` 节点。
        if (token.type === 'string') {
            current++;

            return {
                type: 'StringLiteral',
                value: token.value,
            };
        }

        // 接下来我们处理 CallExpressions。当遇到开括号时开始处理。
        if (
            token.type === 'paren' &&
            token.value === '('
        ) {

            // 我们递增 `current` 来跳过括号，因为在 AST 中我们不关心括号本身。
            token = tokens[++current];

            // 创建一个基础节点，类型为 `CallExpression`，我们将函数名设置为当前 token 的值，
            // 因为开括号后面的 token 是函数名。
            let node = {
                type: 'CallExpression',
                name: token.value,
                params: [],
            };

            // 再次递增 `current` 来跳过函数名 token。
            token = tokens[++current];

            // 现在我们要遍历每个作为 `CallExpression` 参数的 token，直到遇到闭括号。
            //
            // 这里使用了递归。不尝试解析无限嵌套的节点，而是依赖递归来解析。
            //
            // 举个例子，看看我们的 Lisp 代码。你可以看到 `add` 的参数是一个数字和一个嵌套的 `CallExpression`，
            // 它包含自己的数字。
            //
            //   (add 2 (subtract 4 2))
            //
            // 在我们的 tokens 数组中，有多个闭括号。
            //
            // 我们依赖嵌套的 `walk` 函数来递增 `current` 变量，直到超过任何嵌套的 `CallExpression`。

            // 创建一个 `while` 循环，直到遇到 `type` 为 `'paren'` 且 `value` 为闭括号的 token。
            while (
                (token.type !== 'paren') ||
                (token.type === 'paren' && token.value !== ')')
            ) {
                // 调用 `walk` 函数，返回一个 `node`，并将其推入 `node.params` 数组。
                node.params.push(walk());
                token = tokens[current];
            }

            // 最后一次递增 `current` 来跳过闭括号。
            current++;

            // 返回节点。
            return node;
        }

        // 如果到这里仍未识别 token 的类型，抛出一个错误。
        throw new TypeError(token.type);
    }

    // 现在，我们创建一个 AST，它的根节点是一个 `Program` 节点。
    let ast = {
        type: 'Program',
        body: [],
    };

    // 启动 `walk` 函数，将节点推入 `ast.body` 数组。
    //
    // 我们在循环中执行这个操作，因为程序可以有多个 `CallExpression` 连续出现，而不是嵌套的形式。
    //
    //   (add 2 2)
    //   (subtract 4 2)
    //
    while (current < tokens.length) {
        ast.body.push(walk());
    }

    // 解析器结束时返回 AST。
    return ast;
}

/**
 * ============================================================================
 *                                 ⌒(❀>◞౪◟<❀)⌒
 *                               THE TRAVERSER!!!
 * ============================================================================
 */

/**
 * 现在我们有了 AST，我们希望能够使用访问者访问不同的节点。每当遇到匹配类型的节点时，
 * 我们需要能够调用访问者上的方法。
 *
 *   traverse(ast, {
 *     Program: {
 *       enter(node, parent) {
 *         // ...
 *       },
 *       exit(node, parent) {
 *         // ...
 *       },
 *     },
 *
 *     CallExpression: {
 *       enter(node, parent) {
 *         // ...
 *       },
 *       exit(node, parent) {
 *         // ...
 *       },
 *     },
 *
 *     NumberLiteral: {
 *       enter(node, parent) {
 *         // ...
 *       },
 *       exit(node, parent) {
 *         // ...
 *       },
 *     },
 *   });
 */

// 我们定义一个 traverser 函数，接受一个 AST 和一个 visitor。在这里我们将定义两个函数...

function traverser(ast, visitor) {

    // 一个 `traverseArray` 函数，允许我们迭代一个数组，并调用我们将要定义的 `traverseNode` 函数。
    function traverseArray(array, parent) {
        array.forEach(child => {
            traverseNode(child, parent);
        });
    }

    // `traverseNode` 函数将接受一个 `node` 和它的 `parent` 节点，以便将它们传递给我们的 visitor 方法。
    function traverseNode(node, parent) {

        // 我们首先检查 visitor 中是否有匹配 `type` 的方法。
        let methods = visitor[node.type];

        // 如果存在此节点类型的 `enter` 方法，我们将用 `node` 和 `parent` 调用它。
        if (methods && methods.enter) {
            methods.enter(node, parent);
        }

        // 接下来我们根据当前节点类型分别处理。
        switch (node.type) {

            // 我们从顶层的 `Program` 开始。由于 Program 节点具有名为 body 的节点数组，我们将调用 `traverseArray` 进行递归遍历。
            case 'Program':
                traverseArray(node.body, node);
                break;

            // 接下来我们对 `CallExpression` 做同样的处理，并遍历它们的 `params`。
            case 'CallExpression':
                traverseArray(node.params, node);
                break;

            // 对于 `NumberLiteral` 和 `StringLiteral`，由于没有子节点需要访问，我们直接 break。
            case 'NumberLiteral':
            case 'StringLiteral':
                break;

            // 如果我们没有识别出节点类型，则抛出错误。
            default:
                throw new TypeError(node.type);
        }

        // 如果存在此节点类型的 `exit` 方法，我们将用 `node` 和 `parent` 调用它。
        if (methods && methods.exit) {
            methods.exit(node, parent);
        }
    }

    // 最后，我们通过使用顶层 AST 调用 `traverseNode` 来启动遍历器，因为 AST 的顶层没有父节点。
    traverseNode(ast, null);
}

/**
 * ============================================================================
 *                                   ⁽(◍˃̵͈̑ᴗ˂̵͈̑)⁽
 *                              THE TRANSFORMER!!!
 * ============================================================================
 */


/**
 * 接下来是转换器。我们的转换器将获取我们构建的 AST，并将其与访问者一起传递给遍历器函数，然后创建一个新的 AST。
 *
 * ----------------------------------------------------------------------------
 *   原始 AST                        |   转换后的 AST
 * ----------------------------------------------------------------------------
 *   {                               |   {
 *     type: 'Program',              |     type: 'Program',
 *     body: [{                      |     body: [{
 *       type: 'CallExpression',     |       type: 'ExpressionStatement',
 *       name: 'add',                |       expression: {
 *       params: [{                  |         type: 'CallExpression',
 *         type: 'NumberLiteral',    |         callee: {
 *         value: '2'                |           type: 'Identifier',
 *       }, {                        |           name: 'add'
 *         type: 'CallExpression',   |         },
 *         name: 'subtract',         |         arguments: [{
 *         params: [{                |           type: 'NumberLiteral',
 *           type: 'NumberLiteral',  |           value: '2'
 *           value: '4'              |         }, {
 *         }, {                      |           type: 'CallExpression',
 *           type: 'NumberLiteral',  |           callee: {
 *           value: '2'              |             type: 'Identifier',
 *         }]                        |             name: 'subtract'
 *       }]                          |           },
 *     }]                            |           arguments: [{
 *   }                               |             type: 'NumberLiteral',
 *                                   |             value: '4'
 * --------------------------------- |           }, {
 *                                   |             type: 'NumberLiteral',
 *                                   |             value: '2'
 *                                   |           }]
 *  (抱歉，另一个比较长。)            |         }
 *                                   |       }
 *                                   |     }]
 *                                   |   }
 * ----------------------------------------------------------------------------
 */

// 现在我们有了接受 lisp ast 的转换器函数。
function transformer(ast) {

    // 我们将创建一个 `newAst`，与之前的 AST 类似，将有一个程序节点。
    let newAst = {
        type: 'Program',
        body: [],
    };

    // 接下来我会稍微偷个懒，使用父节点上的 `context` 属性来将节点推送到其父节点的 `context` 中。
    // 通常情况下，应该有比这更好的抽象，但为了简单起见，我们暂时这样处理。
    //
    // 注意，`context` 是从旧的 AST 引用到新 AST 的引用。
    ast._context = newAst.body;

    // 我们将从调用遍历器函数开始，传入 AST 和一个访问者对象。
    traverser(ast, {

        // 第一个访问者方法接受任何 `NumberLiteral`。
        NumberLiteral: {
            // 进入节点时执行。
            enter(node, parent) {
                // 我们创建一个新的名为 `NumberLiteral` 的节点，并将其推送到父节点的 `context` 中。
                parent._context.push({
                    type: 'NumberLiteral',
                    value: node.value,
                });
            },
        },

        // 接下来是 `StringLiteral`。
        StringLiteral: {
            enter(node, parent) {
                parent._context.push({
                    type: 'StringLiteral',
                    value: node.value,
                });
            },
        },

        // 然后是 `CallExpression`。
        CallExpression: {
            enter(node, parent) {

                // 我们开始创建一个新的 `CallExpression` 节点，并包含嵌套的 `Identifier`。
                let expression = {
                    type: 'CallExpression',
                    callee: {
                        type: 'Identifier',
                        name: node.name,
                    },
                    arguments: [],
                };

                // 接下来我们会在原始的 `CallExpression` 节点上定义一个新的 `context`，
                // 用来引用 `expression` 的参数，以便我们可以推送参数。
                node._context = expression.arguments;

                // 然后我们将检查父节点是否为 `CallExpression`。
                // 如果不是...
                if (parent.type !== 'CallExpression') {

                    // 我们将把我们的 `CallExpression` 节点包装在 `ExpressionStatement` 中。
                    // 这是因为 JavaScript 中顶层的 `CallExpression` 实际上是语句。
                    expression = {
                        type: 'ExpressionStatement',
                        expression: expression,
                    };
                }

                // 最后，我们将我们（可能被包装过的）`CallExpression` 推送到父节点的 `context` 中。
                parent._context.push(expression);
            },
        }
    });

    // 在转换器函数的最后，我们返回刚刚创建的新 AST。
    return newAst;
}


/**
 * ============================================================================
 *                               ヾ（〃＾∇＾）ﾉ♪
 *                            THE CODE GENERATOR!!!!
 * ============================================================================
 */

/**
 * 现在让我们进入最后阶段：代码生成器。
 *
 * 我们的代码生成器将递归调用自身，将树中的每个节点打印到一个巨大的字符串中。
 */

function codeGenerator(node) {

    // 我们将根据节点的 `type` 来分别处理不同类型的节点。
    switch (node.type) {

        // 如果是 `Program` 节点，我们会遍历 `body` 中的每个节点，并将它们运行通过代码生成器，用换行符连接起来。
        case 'Program':
            return node.body.map(codeGenerator)
                .join('\n');

        // 对于 `ExpressionStatement`，我们将在嵌套表达式上调用代码生成器，并添加一个分号...
        case 'ExpressionStatement':
            return (
                codeGenerator(node.expression) +
                ';' // << (...因为我们喜欢以*正确*的方式编写代码)
            );

        // 对于 `CallExpression`，我们将打印 `callee`，添加一个开放的括号，
        // 然后遍历 `arguments` 数组中的每个节点，并通过代码生成器处理它们，用逗号连接，最后加上闭合括号。
        case 'CallExpression':
            return (
                codeGenerator(node.callee) +
                '(' +
                node.arguments.map(codeGenerator)
                    .join(', ') +
                ')'
            );

        // 对于 `Identifier`，我们只需返回节点的名称。
        case 'Identifier':
            return node.name;

        // 对于 `NumberLiteral`，我们只需返回节点的值。
        case 'NumberLiteral':
            return node.value;

        // 对于 `StringLiteral`，我们在节点的值周围添加引号。
        case 'StringLiteral':
            return '"' + node.value + '"';

        // 如果未识别节点类型，则抛出错误。
        default:
            throw new TypeError(node.type);
    }
}

// 编译
const compiler = (sources_code) => {
    let tokens = tokenizer(sources_code)
    let ast = parser(tokens)
    const newAst = transformer(ast)
    return codeGenerator(newAst);
}

let sources_code = "(add 2 (subtract 4 2))"
let output = compiler(sources_code)
console.log(output);